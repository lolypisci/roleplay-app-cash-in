<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Roleplay Archive: Cash In - Student View</title>
</head>
<body>
  <h1>Roleplay Archive: Cash In</h1>
  <h2>Student View</h2>
  <p>Please enter your names and record. You will not be able to playback recordings.</p>

  <!-- Recording section only -->
  <div id="recordSection">
    <label>Buyer Name: <input id="comprador" type="text" placeholder="e.g. John"/></label><br/>
    <label>Seller Name: <input id="vendedor" type="text" placeholder="e.g. Mary"/></label><br/>
    <button id="startBtn">Start Recording</button>
    <button id="stopBtn" disabled>Stop Recording</button>
    <p id="status"></p>
    <div id="postForm" style="display:none;">
      <h3>Purchase Details</h3>
      <textarea id="productos" placeholder="e.g. apple:1.50, bread:2.00"></textarea><br/>
      <button id="submitBtn">Submit Roleplay</button>
    </div>
  </div>

  <script>
    let audioContext;
    let processor;
    let inputNode;
    let recording = false;
    let recordedBuffers = [];
    let sampleRate;

    const startBtn = document.getElementById("startBtn");
    const stopBtn = document.getElementById("stopBtn");
    const statusP = document.getElementById("status");
    const postFormDiv = document.getElementById("postForm");
    const submitBtn = document.getElementById("submitBtn");

    startBtn.onclick = async () => {
      const buyer = document.getElementById("comprador").value.trim();
      const seller = document.getElementById("vendedor").value.trim();
      if (!buyer || !seller) {
        alert("Please enter buyer and seller names before recording.");
        return;
      }
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        sampleRate = audioContext.sampleRate;
        inputNode = audioContext.createMediaStreamSource(stream);
        processor = audioContext.createScriptProcessor(4096, 1, 1);
        recordedBuffers = [];
        recording = true;
        processor.onaudioprocess = e => {
          if (!recording) return;
          const channelData = e.inputBuffer.getChannelData(0);
          recordedBuffers.push(new Float32Array(channelData));
        };
        inputNode.connect(processor);
        processor.connect(audioContext.destination);
        statusP.textContent = "Recording...";
        startBtn.disabled = true;
        stopBtn.disabled = false;
      } catch (err) {
        console.error(err);
        alert("Error accessing microphone.");
      }
    };

    stopBtn.onclick = () => {
      if (recording) {
        recording = false;
        if (processor) processor.disconnect();
        if (inputNode) inputNode.disconnect();
        statusP.textContent = "Recording stopped.";
        postFormDiv.style.display = "block";
        startBtn.disabled = false;
        stopBtn.disabled = true;
      }
    };

    function encodeWAV(buffers, sampleRate) {
      let totalLength = buffers.reduce((sum, buf) => sum + buf.length, 0);
      let buffer = new ArrayBuffer(44 + totalLength * 2);
      let view = new DataView(buffer);
      function writeString(view, offset, string) {
        for (let i = 0; i < string.length; i++) {
          view.setUint8(offset + i, string.charCodeAt(i));
        }
      }
      writeString(view, 0, 'RIFF');
      view.setUint32(4, 36 + totalLength * 2, true);
      writeString(view, 8, 'WAVE');
      writeString(view, 12, 'fmt ');
      view.setUint32(16, 16, true);
      view.setUint16(20, 1, true);
      view.setUint16(22, 1, true);
      view.setUint32(24, sampleRate, true);
      view.setUint32(28, sampleRate * 2, true);
      view.setUint16(32, 2, true);
      view.setUint16(34, 16, true);
      writeString(view, 36, 'data');
      view.setUint32(40, totalLength * 2, true);
      let offset = 44;
      buffers.forEach(buf => {
        for (let i = 0; i < buf.length; i++) {
          let s = Math.max(-1, Math.min(1, buf[i]));
          view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
          offset += 2;
        }
      });
      return new Blob([view], { type: 'audio/wav' });
    }

    submitBtn.onclick = async () => {
      const buyer = document.getElementById("comprador").value.trim();
      const seller = document.getElementById("vendedor").value.trim();
      const productsText = document.getElementById("productos").value.trim();
      if (!productsText) {
        alert("Please enter products and prices.");
        return;
      }
      const wavBlob = encodeWAV(recordedBuffers, sampleRate);
      const formData = new FormData();
      formData.append("comprador", buyer);
      formData.append("vendedor", seller);
      const productsArr = productsText.split(",").map(item => {
        const [name, price] = item.split(":").map(s => s.trim());
        return { nombre: name, precio: parseFloat(price) };
      });
      formData.append("productos_json", JSON.stringify(productsArr));
      formData.append("audio", wavBlob, "roleplay.wav");
      try {
        const resp = await fetch("/upload", {
          method: "POST",
          body: formData
        });
        if (!resp.ok) {
          const err = await resp.json();
          alert("Upload error: " + JSON.stringify(err));
        } else {
          alert("Recording submitted successfully.");
          postFormDiv.style.display = "none";
          statusP.textContent = "";
          recordedBuffers = [];
          document.getElementById("productos").value = "";
        }
      } catch (err) {
        console.error(err);
        alert("Network error during upload.");
      }
    };
  </script>
</body>
</html>
